name: "dart_deadlock"
description: "Detect potential deadlock situations in Dart code using mutexes, locks, or completer patterns"
severity: "high"
patterns:
  - type: "contains"
    pattern: "Mutex()"
  - type: "contains"
    pattern: "lock.acquire()"
  - type: "contains"
    pattern: "synchronized("
  - type: "regex"
    pattern: "await\\s+\\w+\\.acquire\\(\\)"
  - type: "regex"
    pattern: "await\\s+\\w+\\.lock\\(\\)"
  - type: "contains"
    pattern: "Completer<"
  - type: "contains"
    pattern: "completer.future"
  - type: "regex"
    pattern: "await\\s+completer\\.future"
  - type: "contains"
    pattern: "Lock()"
  - type: "contains"
    pattern: "ReadWriteLock()"
  - type: "regex"
    pattern: "final\\s+\\w+\\s+=\\s+Mutex\\(\\)"
  - type: "regex"
    pattern: "final\\s+\\w+\\s+=\\s+Lock\\(\\)"
  - type: "contains"
    pattern: "isolate.pause("
  - type: "regex"
    pattern: "await\\s+Future\\.wait\\("
  - type: "contains"
    pattern: "// TODO: Check for deadlock"
file_types: ["dart"]
fix_suggestion: "Ensure proper lock ordering, use timeouts for lock acquisition, avoid nested locks, and consider using higher-level concurrency primitives. Always release locks in finally blocks."